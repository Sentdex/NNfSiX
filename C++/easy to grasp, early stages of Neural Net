#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <iostream>

#a structure to later use and link a specific thing(a dog for example) with biases, weights and later after training its average final number(the number of the final neural node)
struct Links
{
	std::string name;
	double weight[3] = { 0.8, 0.6, 0.7 };
	double bias = 15;
	double average = 0;
};

class NeuralNet 
{
private:
	Links saveLink[10];
	int cnter = 0;
public:
	void TrainNeural(std::string name, double setsOfSets[10][3]) 
	{
		std::cout << "Training to visualise " + name + "\n";
		#Save the name passed to this function(dog or cat) inside the first index of the private array of "Links" structure
		saveLink[cnter].name = name;
		cnter++;
		for (int i = 0; i < 10; i++)
		{
			#Find the number after multiplying weights and adding bias.
			double total = 0;
			for (int z = 0; z < 3; z++)
			{
				total += setsOfSets[i][z] * saveLink[cnter - 1].weight[z];
			}
			total += saveLink[cnter - 1].bias;
			double tmpAv = saveLink[cnter - 1].average;

			std::cout << "Training set number: " << i << std::endl;
			if (tmpAv > 0) #Make sure this is not the first loop by checking that the 1st index in array of "Links" has the "average" variable set to higher than 0(will happen in 2nd loop)
			{
				#if it entered here this must be the 2nd loop or later
				
				#Check if total now is higher than what we got in the previous loop, if it is decrease the bias or weights
				if (total > tmpAv)
				{
					std::cout << "Too high.. Decreasing..\n";
					
					#Check if weights are already too low
					bool enoughWeight = false;
					for (int b = 0; b < 3; b++)
					{
						if (saveLink[cnter - 1].weight[b] < 0.6)
						{
							enoughWeight = true;
							break;
						}
					}
					#if weights are already too low, then decrease bias instead, or else decrease the highest out of the three weights
					if (enoughWeight)
					{
						saveLink[cnter - 1].bias -= 1.5;
					}
					else
					{
						double highest = saveLink[cnter - 1].weight[0];
						for (int c = 1; c < 3; c++)
						{
							if (saveLink[cnter - 1].weight[c] > highest)
							{
								highest = saveLink[cnter - 1].weight[c];
								if (c == 2)
								{
									saveLink[cnter - 1].weight[2] -= 0.1;
								}
							}
							if (c == 2 && highest != saveLink[cnter - 1].weight[1])
							{
								saveLink[cnter - 1].weight[0] -= 0.1;
							}
							else if (c == 2)
							{
								saveLink[cnter - 1].weight[1] -= 0.1;
							}
						}
					}
				}
				else #Else total must be lower than what we got in the previous loop, increase the bias or weights
				{
					std::cout << "Too low, Increasing..\n";
					
					#Check if weights are already too high
					bool enoughWeight = false;
					for (int b = 0; b < 3; b++)
					{
						if (saveLink[cnter - 1].weight[b] > 0.8)
						{
							enoughWeight = true;
							break;
						}
					}
					#if weights are already too high, then increase bias instead, or else increase the lowest out of the three weights
					if (enoughWeight)
					{
						saveLink[cnter - 1].bias += 1.5;
					}
					else
					{
						double lowest = saveLink[cnter - 1].weight[0];
						for (int c = 1; c < 3; c++)
						{
							if (saveLink[cnter - 1].weight[c] < lowest)
							{
								lowest = saveLink[cnter - 1].weight[c];
								if (c == 2)
								{
									saveLink[cnter - 1].weight[2] += 0.1;
								}
							}
							if (c == 2 && lowest != saveLink[cnter - 1].weight[1])
							{
								saveLink[cnter - 1].weight[0] += 0.1;
							}
							else if (c == 2)
							{
								saveLink[cnter - 1].weight[1] += 0.1;
							}
						}
					}
				}
			}
			saveLink[cnter - 1].average = total;
		}
	}
	std::string Predict(double set[3])
	{
		double save[10];
		int svCnt = 0;
		#loop thru the private "Links" structure until the average inside it equals to 0
		for (int i = 0; i < 10; i++)
		{
			if (saveLink[i].average != 0)
			{
				#Find the average that you get after multiplying a specific structures'(example dog or cat link) weights and after adding bias
				double total = 0;
				for (int z = 0; z < 3; z++)
				{
					total += set[z] * saveLink[i].weight[z];
				}
				total += saveLink[i].bias;
				
				#we need to find out which is larger so we can properly minus from the correct one
				if (total < saveLink[i].average)
				#we then save the difference to the "save" array at the correct index to relate it to the correct thing(dog or cat)
				#so that we can later loop thru it and find out which is lowest(lowest meaning the least difference meaning is closest to the answer)
					save[i] = saveLink[i].average - total;
				else
					save[i] = total - saveLink[i].average;
				svCnt++;
			}
			else
				break;
		}

		#Here we find the lowest difference
		#The "save" array is properly indexed and aligned to match the proper structure(might the structure contain a string with the name "dog" or "cat")
		double lowest = save[0];
		for (int i = 1; i < svCnt; i++)
		{
			if (save[i] < lowest)
			{
				lowest = save[i];
			}
		}
		
		#We loop thru the "save" array and stop and return when we find that the local variable "lowest" is equal to "save[i]", "i" being the index at where lowest was found.
		for (int i = 0; i < 10; i++)
		{
			if (lowest == save[i])
			{
				return saveLink[i].name; #Here we return the "Links" structure private variable "name" at the proper index "i" where we found the "save[i]" to be the lowest difference
			}
		}
	}
};

int main()
{
	#dog and cat fake datasets to use for training, 3 different numbers represent the average RGB of the picture(THESE DATASETS ARE RANDOM AND ARE NOT REALLY THE AVERAGE RGB OF AN ACTUAL PICTURE).
	double dog[10][3] = { { 144, 199, 143 }, { 155, 200, 133 }, { 166, 185, 123 }, { 155, 200, 133 }, { 155, 200, 133 }, { 155, 200, 133 }, { 155, 200, 133 }, { 155, 200, 133 }, { 155, 200, 133 }, { 155, 200, 133 } }; #truely biased? huhuhu
	double cat[10][3] = { { 122, 188, 155 }, { 112, 178, 145 }, { 126, 195, 149 }, { 122, 188, 155 }, { 122, 188, 155 }, { 122, 188, 155 }, { 122, 188, 155 }, { 122, 188, 155 }, { 122, 188, 155 }, { 122, 188, 155 } };

	#An unknown dataset to use later and predict if it's a dog or a cat.
	double unknown[3] = { 131, 190, 147 };

	NeuralNet train;
	train.TrainNeural("dog", dog);
	train.TrainNeural("cat", cat);
	std::string answer = train.Predict(unknown);

	std::cout << answer << std::endl;

	return 0;
}
